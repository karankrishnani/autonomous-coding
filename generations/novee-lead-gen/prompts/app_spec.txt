<project_specification>
  <project_name>Novee Lead Generation Platform</project_name>

  <overview>
    Novee is a conversation-based lead generation platform that helps freelancers, agencies, and consultants discover high-quality client opportunities by monitoring Slack workspaces and LinkedIn (future) for relevant job posts and project requests. Unlike traditional B2B data tools that focus on profile scraping, Novee surfaces real-time opportunities from actual conversations where clients are actively seeking help. The platform consists of a Next.js web dashboard for managing keywords and viewing leads, plus an Electron desktop app that handles secure, user-consented scraping of connected platforms.
    
    Core differentiators: (1) Data accuracy with transparency about sources and freshness, (2) Conversation-first approach capturing real intent, not just contact info, (3) Future AI-powered lead scoring for confidence and estimated value.
  </overview>

  <feature_count>250</feature_count>
  <complexity_tier>Medium</complexity_tier>

  <technology_stack>
    <frontend>
      <framework>Next.js 15 (App Router)</framework>
      <styling>Tailwind CSS</styling>
      <authentication>Supabase Auth (Email/Password + Google OAuth)</authentication>
      <state_management>React Context + Server Components</state_management>
      <deployment>Vercel</deployment>
      <port>3000</port>
    </frontend>
    <backend>
      <database>Supabase (PostgreSQL)</database>
      <api>Next.js API Routes (RESTful)</api>
      <orm>Supabase JS Client</orm>
    </backend>
    <desktop_app>
      <framework>Electron 28+</framework>
      <automation>Playwright (Chromium persistent context)</automation>
      <build_tool>Vite</build_tool>
      <ipc>Electron IPC (contextBridge pattern)</ipc>
      <packaging>electron-builder</packaging>
    </desktop_app>
    <monorepo>
      <manager>pnpm workspaces</manager>
      <build_tool>Turborepo</build_tool>
      <language>TypeScript 5+</language>
      <linting>ESLint + Prettier</linting>
    </monorepo>
  </technology_stack>

  <technical_context>
    <spike_results>
      - Slack SSB Redirect: Use route interception (see .claude/docs/spikes/SLACK_WORKSPACE_CAPTURE_SPEC.md)
      - Slack Message Capture: see .claude/docs/spikes/SLACK_MESSAGE_SEARCH_SPEC.md
    </spike_results>

    <user_journey>
      - MVP User Flow: see .claude/docs/design/Novee-User-Flow-MVP.md
    </user_journey>

    <design_references>
      All UI mockups are in .claude/docs/design/mockups/
      - .claude/docs/design/mockups/01-login.png : Login Page (Web App)
      - .claude/docs/design/mockups/02-desktop-download-instructions.png : Download Desktop from Web App (Text Instructions)
      - .claude/docs/design/mockups/02-desktop-download-support.png : Download Desktop from Web App (Support Instructions)
      - .claude/docs/design/mockups/02-desktop-download-video.png : Download Desktop from Web App (Video Instructions)
      - .claude/docs/design/mockups/02-platform-connect.png : View Platform Connections from Web App (Open Desktop App from Web App)
      - .claude/docs/design/mockups/03a-desktop-app-login.png : Login Page (Desktop App)
      - .claude/docs/design/mockups/03b-desktop-connect-platforms.png : Connect Social Platforms (Desktop App) 
      - .claude/docs/design/mockups/04-keywords-empty.png : Keyword Selections Screen Empty State (Web App)
      - .claude/docs/design/mockups/04-keywords-filled.png : Keyword Selections Screen Filled In (Web App)
      - .claude/docs/design/mockups/05-lead-feed.png : Lead Feed (Web App)
      
      IMPORTANT: Always reference mockups when implementing UI components.
    </design_references>

    <architecture_decisions>
      - Browser Fingerprinting: Collect from web, apply to Playwright (see .claude/docs/architecture/Novee-Browser-Fingerprinting-Spec.md)
      - Monorepo structure: See .claude/docs/architecture/Novee-Monorepo-Build-Plan.md
      - Playwright Caching: See .claude/docs/architecture/Novee-Electron-Playwright-Architecture.md
    </architecture_decisions>
  </technical_context>

  <project_structure>
    novee-lead-gen/
    ├── apps/
    │   ├── web/                    # Next.js 15 web dashboard (Vercel)
    │   │   ├── src/
    │   │   │   ├── app/            # App router pages
    │   │   │   ├── components/     # React components
    │   │   │   ├── lib/            # Utilities, Supabase client
    │   │   │   └── types/          # TypeScript types
    │   │   ├── public/             # Static assets
    │   │   └── package.json
    │   └── desktop/                # Electron app for scraping
    │       ├── src/
    │       │   ├── main.ts         # Main process (Playwright automation)
    │       │   ├── preload.ts      # Context bridge
    │       │   └── renderer/       # Renderer process (UI)
    │       ├── docs/               # Technical specifications
    │       └── package.json
    ├── packages/
    │   └── shared/                 # Shared utilities, types, Supabase client
    │       ├── src/
    │       │   ├── supabase.ts
    │       │   ├── types.ts
    │       │   └── utils.ts
    │       └── package.json
    ├── pnpm-workspace.yaml
    ├── turbo.json
    └── package.json
  </project_structure>

  <prerequisites>
    <environment_setup>
      - Node.js 18+ installed
      - pnpm package manager (npm install -g pnpm)
      - Supabase CLI (for local development)
      - Playwright browsers installed
      - Git for version control
    </environment_setup>
    <external_services>
      - Supabase project (database + auth + storage)
      - Vercel account (for web app deployment)
      - Google OAuth credentials (for Google sign-in)
    </external_services>
  </prerequisites>

  <database_schema>
    <tables>
      <users>
        - id (UUID, PRIMARY KEY, from Supabase Auth)
        - email (TEXT, UNIQUE, NOT NULL)
        - name (TEXT)
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
        - updated_at (TIMESTAMPTZ, DEFAULT NOW())
      </users>

      <user_fingerprints>
        - id (UUID, PRIMARY KEY)
        - user_id (UUID, FOREIGN KEY -> users.id, ON DELETE CASCADE)
        - fingerprint (JSONB, NOT NULL) - stores browser fingerprint data
        - collected_at (TIMESTAMPTZ, DEFAULT NOW())
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
        - updated_at (TIMESTAMPTZ, DEFAULT NOW())
      </user_fingerprints>

      <desktop_app_sessions>
        - id (UUID, PRIMARY KEY)
        - user_id (UUID, FOREIGN KEY -> users.id, ON DELETE CASCADE)
        - device_label (TEXT) - user-friendly device name
        - os_type (TEXT) - Windows, Mac, Linux
        - last_seen_at (TIMESTAMPTZ, DEFAULT NOW())
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
        - updated_at (TIMESTAMPTZ, DEFAULT NOW())
      </desktop_app_sessions>

      <platform_connections>
        - id (UUID, PRIMARY KEY)
        - user_id (UUID, FOREIGN KEY -> users.id, ON DELETE CASCADE)
        - platform (TEXT, NOT NULL, CHECK IN ('SLACK', 'LINKEDIN'))
        - status (TEXT, NOT NULL, CHECK IN ('PENDING', 'CONNECTED', 'DEGRADED', 'DISCONNECTED'))
        - metadata (JSONB, DEFAULT '{}') - workspace URLs, connection details
        - last_checked_at (TIMESTAMPTZ)
        - last_error (TEXT)
        - connected_at (TIMESTAMPTZ)
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
        - updated_at (TIMESTAMPTZ, DEFAULT NOW())
        - UNIQUE(user_id, platform)
      </platform_connections>

      <channels>
        - id (UUID, PRIMARY KEY)
        - platform_connection_id (UUID, FOREIGN KEY -> platform_connections.id, ON DELETE CASCADE)
        - name (TEXT, NOT NULL) - channel/group name
        - type (TEXT) - public, private, DM
        - metadata (JSONB, DEFAULT '{}') - workspace name, channel ID
        - last_run_at (TIMESTAMPTZ) - last scrape time
        - next_run_at (TIMESTAMPTZ) - scheduled next scrape
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
        - updated_at (TIMESTAMPTZ, DEFAULT NOW())
      </channels>

      <user_keyword_groups>
        - id (UUID, PRIMARY KEY)
        - user_id (UUID, FOREIGN KEY -> users.id, ON DELETE CASCADE)
        - active (BOOLEAN, DEFAULT TRUE)
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
        - updated_at (TIMESTAMPTZ, DEFAULT NOW())
      </user_keyword_groups>

      <keywords>
        - id (UUID, PRIMARY KEY)
        - user_keyword_group_id (UUID, FOREIGN KEY -> user_keyword_groups.id, ON DELETE CASCADE)
        - text (TEXT, NOT NULL)
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
        - updated_at (TIMESTAMPTZ, DEFAULT NOW())
      </keywords>

      <posts>
        - id (UUID, PRIMARY KEY)
        - channel_id (UUID, FOREIGN KEY -> channels.id, ON DELETE CASCADE)
        - timestamp (TIMESTAMPTZ, NOT NULL) - when post was created
        - content (TEXT, NOT NULL) - full message text
        - source_url (TEXT) - permalink to original post
        - metadata (JSONB, DEFAULT '{}') - sender, reactions, etc.
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
        - updated_at (TIMESTAMPTZ, DEFAULT NOW())
      </posts>

      <leads>
        - id (UUID, PRIMARY KEY)
        - user_id (UUID, FOREIGN KEY -> users.id, ON DELETE CASCADE)
        - post_id (UUID, FOREIGN KEY -> posts.id, ON DELETE CASCADE)
        - matched_keywords (TEXT[], NOT NULL) - array of matched keywords
        - status (TEXT, DEFAULT 'NEW', CHECK IN ('NEW', 'VIEWED', 'INTERESTED', 'NOT_INTERESTED', 'MARKED_LATER', 'ARCHIVED'))
        - first_viewed_at (TIMESTAMPTZ)
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
        - updated_at (TIMESTAMPTZ, DEFAULT NOW())
        - UNIQUE(user_id, post_id)
      </leads>

      <lead_interactions>
        - id (UUID, PRIMARY KEY)
        - lead_id (UUID, FOREIGN KEY -> leads.id, ON DELETE CASCADE)
        - user_id (UUID, FOREIGN KEY -> users.id, ON DELETE CASCADE)
        - action (TEXT, NOT NULL, CHECK IN ('INTERESTED', 'NOT_INTERESTED', 'MARKED_LATER', 'OPENED_SOURCE'))
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
      </lead_interactions>

      <onboarding_events>
        - id (UUID, PRIMARY KEY)
        - user_id (UUID, FOREIGN KEY -> users.id, ON DELETE CASCADE)
        - event (TEXT, NOT NULL, CHECK IN ('ACCOUNT_CREATED', 'WEB_LOGIN', 'BROWSER_FINGERPRINT_CAPTURED', 'DESKTOP_DOWNLOADED', 'DESKTOP_INSTALLED', 'PLATFORM_CONNECTED', 'KEYWORDS_SELECTED', 'FIRST_LEAD_VIEWED'))
        - platform_connection_id (UUID, FOREIGN KEY -> platform_connections.id, ON DELETE SET NULL)
        - occurred_at (TIMESTAMPTZ, DEFAULT NOW())
        - metadata (JSONB, DEFAULT '{}')
        - created_at (TIMESTAMPTZ, DEFAULT NOW())
      </onboarding_events>

      <scraper_configs>
        - platform (TEXT, PRIMARY KEY, CHECK IN ('SLACK', 'LINKEDIN', 'REDDIT'))
        - version (TEXT, NOT NULL)
        - config (JSONB, NOT NULL) - selectors, timing, strategies
        - updated_at (TIMESTAMPTZ, DEFAULT NOW())
      </scraper_configs>
    </tables>

    <indexes>
      CREATE INDEX idx_leads_user_status ON leads(user_id, status);
      CREATE INDEX idx_leads_created ON leads(created_at DESC);
      CREATE INDEX idx_posts_channel ON posts(channel_id, timestamp DESC);
      CREATE INDEX idx_platform_connections_user ON platform_connections(user_id);
      CREATE INDEX idx_channels_platform ON channels(platform_connection_id);
    </indexes>

    <rls_policies>
      - Users can only access their own data
      - All tables scoped to authenticated user via user_id
      - Platform connections tied to user
      - Leads scoped to user who created them
      - Scraper configs are public (read-only for desktop app)
    </rls_policies>
  </database_schema>

  <core_features>
    <authentication>
      - User registration with email/password via Supabase Auth
      - Google OAuth sign-in integration
      - Email verification flow (optional for MVP)
      - Password reset via email link
      - Session management with JWT tokens
      - Persistent login (remember me) via cookies
      - User logout clears session
      - Profile page showing user info (name, email)
      - Profile editing (update name)
      - Protected routes redirect unauthenticated users to login
      - Desktop app authenticates using same Supabase Auth
    </authentication>

    <onboarding_flow>
      - Desktop app download page with platform detection (Windows/Mac)
      - Installation guide with screenshots/video
      - Desktop app login screen connects to web auth
      - Platform connection UI (list of Slack, LinkedIn)
      - "Connect Slack" button launches Playwright browser
      - Slack workspace capture and storage in database
      - Connection status indicators (Connected, Disconnected, Degraded)
      - Keyword selection page with pre-populated suggestions
      - Keyword suggestions organized by: Skills, Tools, Industry
      - Custom keyword input field
      - Visual pills showing selected keywords
      - "Skip for now" option proceeds to empty dashboard
      - Progress indicator shows onboarding steps completed
      - Onboarding events tracked in database
    </onboarding_flow>

    <platform_connections>
      - Desktop app displays list of supported platforms
      - Each platform shows connection status badge
      - "Connect" button opens platform login in embedded Playwright browser
      - Slack: Capture all workspace names and URLs
      - Slack: Handle SSB redirect without protocol dialogs
      - Slack: Store workspace data in platform_connections table
      - Slack: Background sync every 24 hours to refresh connections
      - Connection status page in web app shows all platforms
      - Last sync time displayed for each connection
      - "Reconnect" button triggers desktop app to re-authenticate
      - Troubleshooting tips shown for disconnected platforms
      - Privacy messaging: "We only read, never post"
    </platform_connections>

    <keyword_management>
      - Keyword selection UI with category tabs (Skills, Tools, Industry)
      - Pre-populated keyword suggestions by user's discipline
      - Click to add keyword (becomes pill)
      - Click pill to remove keyword
      - Custom keyword text input
      - Validation: keywords must be 2-50 characters
      - Save keywords creates user_keyword_groups and keywords records
      - Edit keywords page loads existing selections
      - Add new keywords to existing group
      - Remove keywords from group
      - Clear all keywords option with confirmation
      - Keyword pills displayed on dashboard filters
    </keyword_management>

    <scraping_engine>
      - Desktop app runs scheduled scrape every 24 hours
      - Fetch scraper config from Supabase before each scrape
      - Use Playwright to automate Slack message search
      - Search for each user keyword across all connected workspaces
      - Handle "Show more" button clicks to expand truncated messages
      - Extract: message text, sender, channel, timestamp, permalink
      - Store scraped posts in posts table
      - Match posts against user keywords (case-insensitive)
      - Create leads in leads table for matched posts
      - Notify web app via Supabase realtime when new leads created
      - Retry logic for failed scrapes (3 attempts)
      - Error logging to database (last_error field)
      - Graceful handling of Slack UI changes via remote config
      - Desktop app shows scraping status in UI
    </scraping_engine>

    <lead_dashboard>
      - Lead feed displays cards of matched leads
      - Each card shows: post snippet (200 chars), platform icon, channel, relative timestamp, matched keywords (pills), sender name
      - Tab filters: New, Viewed, Interested, Not Interested, Marked for Later, Archived
      - Platform filter: All, Slack, LinkedIn
      - Keyword filter: multiselect of user's keywords
      - Date range filter: Today, This Week, This Month, All Time
      - Sort by: Newest First, Oldest First, Most Keywords Matched
      - Pagination: 20 leads per page
      - "Mark as Interested" button updates lead status
      - "Mark as Not Interested" button updates lead status
      - "Mark for Later" button updates lead status
      - "Open Source" button opens Slack permalink in new tab/window
      - Clicking lead card expands to show full message
      - Lead counts shown in tab badges (e.g., "New (5)")
      - Real-time updates when desktop app finds new leads
      - Empty state: No platforms connected (show CTA to connect)
      - Empty state: No keywords selected (show CTA to add keywords)
      - Empty state: No leads found yet (show next scan time)
      - Demo leads shown for new users with tooltip explaining they're examples
    </lead_dashboard>

    <scraper_configuration_system>
      - Scraper configs stored in scraper_configs table
      - API endpoint GET /api/scraper-config/{platform} returns current config
      - Config includes: selectors, timing delays, retry strategies
      - Desktop app fetches config before each scrape
      - Fallback to last-known-good config if fetch fails
      - Version number tracks config updates
      - Admin UI (future) to update configs
      - Config changes take effect on next scrape (no desktop app update needed)
    </scraper_configuration_system>

    <analytics_tracking>
      - Track onboarding events: signup, login, desktop download, platform connected, keywords selected, first lead viewed
      - Track lead interactions: interested, not interested, marked later, opened source
      - Track scraper runs: success/failure, duration, leads found
      - Dashboard shows user stats: total leads, leads this week, active platforms
      - Admin dashboard (future) shows aggregate metrics
    </analytics_tracking>

    <user_interface>
      - Responsive layout: mobile (375px), tablet (768px), desktop (1280px+)
      - Light theme (default)
      - Dark theme toggle in header
      - Consistent color palette: primary (blue), success (green), error (red), warning (amber)
      - Loading states with spinners for async operations
      - Skeleton loaders for data fetching
      - Toast notifications for actions (success, error, info)
      - Error boundaries catch React errors gracefully
      - Form validation with inline error messages
      - Hover states on interactive elements
      - Focus states for keyboard navigation
      - Empty states with helpful CTAs
      - 404 page for non-existent routes
      - Header with logo, navigation, user menu
      - Sidebar for desktop (collapsible on tablet/mobile)
      - Footer with links: Privacy, Terms, Support
    </user_interface>

    <security_privacy>
      - All routes protected with Supabase Row Level Security
      - Users can only access their own data
      - Desktop app uses Node integration disabled
      - Desktop app uses Context isolation enabled
      - IPC handlers validate all input
      - No credentials stored in desktop app code
      - Playwright persistent context maintains login state locally
      - Browser fingerprinting: collect from web app, apply to Playwright
      - HTTPS only for web app
      - CSP headers prevent XSS attacks
      - Rate limiting on API routes (future)
      - User can disconnect platforms anytime
      - Data deleted on account deletion
    </security_privacy>

    <data_management>
      - Form validation on all inputs
      - Server-side validation matches client-side
      - Graceful handling of API errors
      - Database transactions for multi-step operations
      - Soft delete for leads (archived status)
      - Hard delete option (future) with confirmation
      - Data export: CSV of all leads (future)
      - Data import: keywords from CSV (future)
    </data_management>
  </core_features>

  <api_endpoints_summary>
    <authentication>
      - POST /auth/signup - Create new user account (Supabase Auth)
      - POST /auth/login - Login with email/password (Supabase Auth)
      - POST /auth/logout - Clear session (Supabase Auth)
      - GET /auth/session - Get current user session (Supabase Auth)
      - POST /auth/reset-password - Send password reset email
      - POST /auth/google - Google OAuth callback
    </authentication>

    <onboarding>
      - POST /api/onboarding/events - Track onboarding event
      - GET /api/onboarding/status - Get user's onboarding completion status
    </onboarding>

    <platforms>
      - GET /api/platforms - List all supported platforms
      - GET /api/platforms/connections - Get user's platform connections
      - POST /api/platforms/connections - Create platform connection
      - PUT /api/platforms/connections/:id - Update connection status
      - DELETE /api/platforms/connections/:id - Disconnect platform
      - GET /api/platforms/connections/:id/channels - Get channels for connection
    </platforms>

    <keywords>
      - GET /api/keywords - Get user's keyword groups and keywords
      - POST /api/keywords - Create keyword group with keywords
      - PUT /api/keywords/:groupId - Update keywords in group
      - DELETE /api/keywords/:groupId - Delete keyword group
      - GET /api/keywords/suggestions - Get keyword suggestions by discipline
    </keywords>

    <leads>
      - GET /api/leads - List leads with filters (platform, keyword, status, date range, pagination)
      - GET /api/leads/:id - Get single lead with full post content
      - PUT /api/leads/:id/status - Update lead status
      - POST /api/leads/:id/interactions - Track lead interaction
      - GET /api/leads/stats - Get lead counts by status
    </leads>

    <scraper>
      - GET /api/scraper-config/:platform - Get scraper config for platform
      - PUT /api/scraper-config/:platform - Update scraper config (admin only)
      - POST /api/scraper/run - Trigger manual scrape (from desktop app)
      - GET /api/scraper/status - Get last scrape status and next scheduled time
    </scraper>

    <user>
      - GET /api/user/profile - Get user profile
      - PUT /api/user/profile - Update user profile
      - POST /api/user/fingerprint - Store browser fingerprint
      - GET /api/user/fingerprint - Get stored fingerprint (for desktop app)
    </user>

    <desktop>
      - POST /api/desktop/session - Register desktop app session
      - PUT /api/desktop/session/:id - Update session last_seen_at
      - GET /api/desktop/session - Get active desktop sessions
    </desktop>
  </api_endpoints_summary>

### Desktop App Security
- No credentials stored in code
- Uses Playwright persistent context (maintains login state locally)
- Node integration disabled in renderer
- Context isolation enabled
- IPC validation on all handlers

### Web App Security
- Supabase Row Level Security (RLS) policies
- All user data scoped to authenticated user
- HTTPS only
- CSP headers
- Rate limiting on API routes

### Browser Fingerprinting (Anti-Detection)
- Collect real user fingerprint via web app JavaScript
- Store in `user_fingerprints` table
- Desktop app fetches and applies to Playwright context
- Reduces detection by LinkedIn/Slack

### Data Privacy
- Users control which platforms to connect
- Clear messaging: "We only read, never post"
- Users can disconnect platforms anytime
- Data deleted on account deletion

  <special_considerations>
    <desktop_app_challenges>
      - Slack detection: Use browser fingerprinting, respect rate limits, use persistent context
      - DOM changes breaking scrapers: Remote config system allows hot-fixes without app updates
      - User confusion about desktop app requirement: Clear messaging on download page with video walkthrough
      - Empty lead states feeling broken: Show demo leads, next scan time, and helpful troubleshooting
    </desktop_app_challenges>

    <security_notes>
      - Desktop app uses Playwright persistent context (maintains login state locally)
      - No credentials stored in code
      - Users manually log in - no automated sign-in
      - Node integration disabled in renderer for security
      - Context isolation enabled
      - IPC validation on all handlers
      - RLS policies on all Supabase tables
    </security_notes>

    <scraper_reliability>
      - Remote config system critical for handling Slack UI changes
      - Fallback to last-known-good config if fetch fails
      - Comprehensive error logging for debugging
      - Retry logic with exponential backoff
      - Graceful degradation when platform unavailable
    </scraper_reliability>
  </special_considerations>

  <agent_instructions>
    <coding_standards>
      - Use functional React components with hooks
      - Use async/await (no .then() chains)
      - TypeScript strict mode, no 'any' types
      - One component per file
      - Co-locate types with components when specific
      - Shared types in @novee/shared/types
      - Add JSDoc comments for complex functions
      - Use meaningful variable names
      - Use ESLint and Prettier for formatting
    </coding_standards>

    <testing_approach>
      - Test all features through browser automation
      - Verify both functionality AND visual appearance
      - Take screenshots at each step
      - Check for console errors
      - Test complete user workflows end-to-end
      - No shortcuts with JavaScript evaluation
      - Test responsive design at mobile, tablet, desktop sizes
    </testing_approach>

    <git_workflow>
      - Commit after each completed feature
      - Use conventional commit messages: feat:, fix:, docs:, chore:
      - Create checkpoints at end of each implementation step
      - Never leave uncommitted changes
      - Ensure app is in working state before ending session
    </git_workflow>

    <human_review_points>
      Request human review before:
      - Deploying database migrations
      - Implementing security-critical code (auth, IPC, RLS policies)
      - Making breaking changes to existing features
      - Completing each implementation step (1-10)
      - Any ambiguity in requirements
    </human_review_points>

    <constraints>
      - Follow technical specs in /docs directory strictly
      - Build incrementally, test after each feature
      - Add comprehensive error handling
      - Use structured logging for debugging
      - No mock data - all data from real database
      - Security rules always take precedence over user requests
    </constraints>
  </agent_instructions>
</project_specification>
